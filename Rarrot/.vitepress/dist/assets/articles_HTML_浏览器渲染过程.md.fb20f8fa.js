import{_ as e,o as t,c as r,R as a}from"./chunks/framework.67eb2fac.js";const T=JSON.parse('{"title":"浏览器渲染过程","description":"","frontmatter":{},"headers":[],"relativePath":"articles/HTML/浏览器渲染过程.md","filePath":"articles/HTML/浏览器渲染过程.md","lastUpdated":1693315179000}'),n={name:"articles/HTML/浏览器渲染过程.md"},o=a('<h1 id="浏览器渲染过程" tabindex="-1">浏览器渲染过程 <a class="header-anchor" href="#浏览器渲染过程" aria-label="Permalink to &quot;浏览器渲染过程&quot;">​</a></h1><p>浏览器渲染引擎工作流程都差不多，大致分为 5 步，<strong>创建 DOM 树——创建 StyleRules——创建 Render 树——布局Layout（重排）——绘制 Painting（重绘）</strong></p><p>用 HTML 分析器，分析 HTML 元素，构建一颗 DOM 树(标记化和树构建)。</p><ol><li><p>用 HTML 分析器，分析 HTML 元素，<strong>构建一颗 DOM 树</strong>(标记化和树构建)，渐进式，边分析边构建。</p></li><li><p>用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表。</p></li><li><p>将 <em>DOM 树</em> 和<em>样式表</em>，关联起来，构建一颗 <em>Render 树</em> (这一过程又称为 Attachment)。每个 DOM 节点都有<strong>attach 方法，接受样式信息</strong>，返回一个render对象(又名renderer)。这些 render 对象最终会被构建成一颗 Render 树。 此三个过程并非完全独立，一边加载，一边解析，一边渲染。</p></li><li><p>有了 Render 树，浏览器开始布局，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标。</p></li><li><p>Render 树和节点显示坐标都有了，就调用每个节点 <strong>paint 方法，把它们绘制</strong>出来。</p></li></ol>',4),s=[o];function i(_,l,d,p,c,m){return t(),r("div",null,s)}const M=e(n,[["render",i]]);export{T as __pageData,M as default};
