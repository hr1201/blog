import{_ as e,c as t,o as r,R as l}from"./chunks/framework.c3LoRyG_.js";const x=JSON.parse('{"title":"flex布局","description":"","frontmatter":{},"headers":[],"relativePath":"articles/css/弹性布局.md","filePath":"articles/css/弹性布局.md","lastUpdated":1695433746000}'),a={name:"articles/css/弹性布局.md"},i=l('<h1 id="flex布局" tabindex="-1">flex布局 <a class="header-anchor" href="#flex布局" aria-label="Permalink to &quot;flex布局&quot;">​</a></h1><p>Flex是Flexible box的缩写，意为&quot;弹性布局&quot;，一种一维的布局模型，为盒状模型提供最大的灵活性。</p><br><p><strong>一维布局模型</strong>原因：</p><p>一个flexbox一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是网格布局，同时也是二维布局 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout" target="_blank" rel="noreferrer">CSS Grid Layout</a>，可以同时处理行和列。</p><br><p><strong>使用flex</strong>原因：</p><p>以下简单的布局需求是难以或不可能用这样的工具（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats" target="_blank" rel="noreferrer">floats</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning" target="_blank" rel="noreferrer">positioning</a>）方便且灵活的实现的：</p><ul><li>在父内容里面垂直居中一个块内容。</li><li>使容器的所有子项占用等量的可用宽度/高度，而不管有多少宽度/高度可用。</li><li>使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。</li></ul><h2 id="设置在容器上的属性有6个" tabindex="-1">设置在容器上的属性有6个 <a class="header-anchor" href="#设置在容器上的属性有6个" aria-label="Permalink to &quot;设置在容器上的属性有6个&quot;">​</a></h2><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h2 id="flexbox的两根轴线-主轴和交叉轴" tabindex="-1">flexbox的两根轴线（主轴和交叉轴） <a class="header-anchor" href="#flexbox的两根轴线-主轴和交叉轴" aria-label="Permalink to &quot;flexbox的两根轴线（主轴和交叉轴）&quot;">​</a></h2><p>flexbox的所有属性<code>都跟这两根轴线</code>有关。</p><h3 id="主轴" tabindex="-1">主轴 <a class="header-anchor" href="#主轴" aria-label="Permalink to &quot;主轴&quot;">​</a></h3><p>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction">flex-direction</a> 定义：</p><table><thead><tr><th>主轴的属性值</th><th>效果</th></tr></thead><tbody><tr><td>row，row-reverse</td><td>主轴沿着左右方向延伸，也就是inline排列方向<br>row-server则起始线和终止线交换，<br>从左到右为c-b-a</td></tr><tr><td>column，column-reverse</td><td>主轴沿着上下方向延伸，也就是block排列方向<br>column-server则起始线和终止线交换，<br>从上到下为c-b-a</td></tr></tbody></table><h3 id="交叉轴" tabindex="-1">交叉轴 <a class="header-anchor" href="#交叉轴" aria-label="Permalink to &quot;交叉轴&quot;">​</a></h3><p>交叉轴垂直于主轴，如果主轴为flex-direction(主轴)设置为row或row-reverse，交叉轴方向是沿着列向下的。</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221126222953959.png" alt="image-20221126222953959"></p><p>如果主轴方向设成了 column 或者 column-reverse，交叉轴就是水平方向。</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221126223209912.png" alt="image-20221126223209912"></p><h2 id="起始线和终止线" tabindex="-1">起始线和终止线 <a class="header-anchor" href="#起始线和终止线" aria-label="Permalink to &quot;起始线和终止线&quot;">​</a></h2><p>如果flex-direction是row，并且书写的是英文，那么主轴的起始线是左边，终止线是右边。</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221127094217759.png" alt="image-20221127094217759"></p><br><p>如果在书写阿拉伯文，那么主轴的起始线是右边，终止线是左边。</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221127094309260.png" alt="image-20221127094309260"></p><br><p>所以两种书写模式下，交叉轴的起始线是flex的顶部，终止线则是底部，也就是竖直方向，因为这两种语言都是水平书写模式。</p><h2 id="flex容器" tabindex="-1">Flex容器 <a class="header-anchor" href="#flex容器" aria-label="Permalink to &quot;Flex容器&quot;">​</a></h2><p>采用flexbox的区域叫做flex容器，为了创建flex容器，将容器的display属性值改为flex或inline-flex，那么容器中的直系子元素就会变为<strong>flex元素</strong>。flex容器中的所有flex元素都会有下列行为：</p><ul><li>元素排列为一行 (主轴flex-direction 属性的初始值是 row)。</li><li>元素从主轴的<strong>起始线</strong>开始。</li><li>元素不会在主维度方向拉伸，但是可以缩小。</li><li>元素被拉伸来填充交叉轴大小。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis" target="_blank" rel="noreferrer">flex-basis</a> 属性为 auto。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap" target="_blank" rel="noreferrer">flex-wrap</a> 属性为 nowrap。</li></ul><br><p>未使用弹性布局前：</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221126212440860.png" alt="image-20221126212440860"></p><br><p>使用弹性布局后，设<code>display:flex</code>或<code>display:inline-flex</code>，变成三列布局，实则是主轴<code>flex-direction：row</code>影响，以自己的大小作为主轴大小，高度等高，呈线性排列，如果太多元素超出容器，会溢出而不换行。出现一些元素比其他元素高，则会拉伸交叉轴以填满其大小：</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221126212820282.png" alt="image-20221126212820282"></p><p>设<code>flex-direction: row-reverse</code>后起始线和终止线交换，效果为：</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221127115544883.png" alt="image-20221127115544883"></p><h2 id="用flex-wrap实现多行flex容器" tabindex="-1">用<code>flex-wrap</code>实现多行flex容器 <a class="header-anchor" href="#用flex-wrap实现多行flex容器" aria-label="Permalink to &quot;用`flex-wrap`实现多行flex容器&quot;">​</a></h2><p>虽然flexbox是一维模型，但可以使我们的flex项目应用到多行中，使用<strong>flex-wrap</strong>属性，</p><p>属性值设置为wrap：把每一行看作一个新的flex容器，任何空间分布都将在该行上发生，而不影响其他行。如果有一行太大，那么剩余内容换行显示；</p><p>使用wrap-reverse：起始线与终止线相反；</p><p>默认值为<strong>nowrap</strong>，缩小以适应容器，如果项目子元素无法缩小或缩小太少，将会溢出。</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221127145602265.png" alt="image-20221127145602265"></p><p>上述简写形式为<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-flow">flex-flow</a>：row wrap；(第一个为flex-direction属性的值，第二个为flex-wrap属性的值)。</p><h2 id="容器上元素间的空间对齐和空间分配" tabindex="-1">容器上元素间的空间对齐和空间分配 <a class="header-anchor" href="#容器上元素间的空间对齐和空间分配" aria-label="Permalink to &quot;容器上元素间的空间对齐和空间分配&quot;">​</a></h2><p>Flexbox的一个关键特性为能够设置flex元素沿主轴方向和交叉轴方向的<strong>对齐</strong>方式，以及它们之间的<strong>空间分配</strong>。</p><p>如果要知道所有布局(不局限于flexbox)的对齐属性是如何起作用的，查看<a href="https://www.w3.org/TR/css-align-3/" target="_blank" rel="noreferrer">Box Alignment 规范</a>。</p><br><ol><li>设置元素交叉轴方向对齐可以使<code>align-items</code>，多用于多个项；用在单项的<code>align-self</code>,此属性接受与align-items及其特定项的值相同的值。</li></ol><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>stretch(默认)</td><td>元素被拉伸到最高元素的高度，实际上是被拉伸来填满flex容器——最高的元素定义了容器的高度。</td></tr><tr><td>flex-start</td><td>按flex容器的顶部对齐</td></tr><tr><td>flex-end</td><td>按flex容器的下部对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr><tr><td>baseline</td><td>项目显示在容器的基线处</td></tr></tbody></table><br><p><code>stretch</code></p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221201170602015.png" alt="image-20221201170602015"></p><br><p><code>flex-start</code></p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221201170400299.png" alt="image-20221201170400299"></p><br><p><code>flex-end</code></p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221201170311058.png" alt="image-20221201170311058"></p><br><p><code>center</code></p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221201170455446.png" alt="image-20221201170455446"></p><br><ol><li>使元素在主轴方向上对齐使用属<code>justify-content</code>，</li></ol><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>stretch</td><td>与flex-start作用相似</td></tr><tr><td>flex-start(默认)</td><td>元素从容器的起始线排列</td></tr><tr><td>flex-end</td><td>元素从容器的终止线排列</td></tr><tr><td>center</td><td>中间排列</td></tr><tr><td>space-around</td><td>使每个元素的左右空间相等</td></tr><tr><td>space-between</td><td>将元素排布好后的可用空间拿出来平均分到元素之间，间隔相等</td></tr></tbody></table><br><p><code>flex-start</code>在最左边<code>flex-end</code>在最右边<code>center</code>在中间 <img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221201171826878.png" alt="image-20221201171826878"></p><br><p><code>space-around</code>元素左右空间相等 <img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221201173245042.png" alt="image-20221201173245042"></p><br><p><code>space-between</code>平均分配空间 <img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221201173349995.png" alt="image-20221201173349995"></p><br><ol><li>用于设置多行 ，使<code>align-content</code>：</li></ol><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>stretch</td><td>与flex-start作用相似，行被拉伸以适应容器</td></tr><tr><td>flex-start(默认)</td><td>行被打包在容器的顶部</td></tr><tr><td>flex-end</td><td>行被打包在容器的底部</td></tr><tr><td>center</td><td>行被打包在容器的垂直中心</td></tr><tr><td>space-around</td><td>行周围等间距显示</td></tr><tr><td>space-between</td><td>将元素排布好后的可用空间拿出来平均分到元素之间，间隔相等</td></tr></tbody></table><p>总结：align-content决定行之间的间距，align-items决定了项目作为一个整体在容器中<strong>交叉轴</strong>上的对齐方式。当只有一行时，align-items不起作用。justify-content决定了项目为一个整体在容器中主轴上的对齐方式。</p><p>注意：当使用row或column时，注意主轴与交叉轴的切换</p><h2 id="flex元素上的属性" tabindex="-1">flex元素上的属性 <a class="header-anchor" href="#flex元素上的属性" aria-label="Permalink to &quot;flex元素上的属性&quot;">​</a></h2><p>为了更好控制flex元素，以下六个属性可以使用：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow" target="_blank" rel="noreferrer">flex-grow</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-shrink" target="_blank" rel="noreferrer">flex-shrink</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis" target="_blank" rel="noreferrer">flex-basis</a></li><li>flex</li><li>order</li><li>align-self</li></ul><br><p>前三个属性其实是改变了flex容器中的可用空间的行为。可用空间对于flex元素的对齐行为也很重要。</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221127153322357.png" alt="image-20221127153322357"></p><p>可用空间即为500px；使用了300px，在默认情况下，这后面200px即<strong>可用空间</strong>会给到最后一个元素后面。现在我们想要对空间进行均匀分配。</p><h3 id="flex-basis" tabindex="-1">flex-basis <a class="header-anchor" href="#flex-basis" aria-label="Permalink to &quot;flex-basis&quot;">​</a></h3><p>用于定义该元素的空间大小，flex容器里除了元素所占空间以外的<strong>富余空间</strong>就是<strong>可用空间</strong>。</p><p>默认值为auto，上面a，b，c都为100px，那么flex-basis的值为100px。如果没有设定尺寸，flex-basis采用元素内容的尺寸。所以上面例子中所有子元素均匀分布，排成一行，且自动分配大小充分展示元素的内容。</p><h3 id="flex-grow" tabindex="-1">flex-grow <a class="header-anchor" href="#flex-grow" aria-label="Permalink to &quot;flex-grow&quot;">​</a></h3><p>若此属性值为正整数，flex元素会以flex-basis为基础，沿主轴方向增长尺寸。使该元素延展，占据此方向轴上的<strong>可用空间</strong>。</p><p>例如，我们给one空间为2，其余为1，进行按比例分配空间那么可用空间one占2/4，two和three各占1/4,。</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221127164945730.png" alt="image-20221127164945730"></p><h3 id="flex-shrink" tabindex="-1">flex-shrink <a class="header-anchor" href="#flex-shrink" aria-label="Permalink to &quot;flex-shrink&quot;">​</a></h3><p>flex-grow是处理flex元素在主轴上<strong>增加</strong>空间的问题，而flex-shrink则是用来处理flex元素<strong>收缩</strong>的问题。可以设置<strong>属性值为正整数</strong>来缩小它所占空间到flex-basis(占据空间)以下。</p><p>给flex-grow和flex-shrink赋值时要注意比例</p><h2 id="简写" tabindex="-1">简写 <a class="header-anchor" href="#简写" aria-label="Permalink to &quot;简写&quot;">​</a></h2><p>按照顺<code>flex-grow</code>，<code>flex-shrin</code>，<code>flex-basic</code>排布。</p><p>预定义的简写形式：</p><ul><li>flex: initial</li><li>flex: auto</li><li>flex: none</li><li>flex: &lt;//positive-number&gt;</li></ul><p><code>flex: initial</code> 是把 flex 元素重置为 Flexbox 的初始值，它相当于 flex: 0 1 auto。在这里 flex-grow 的值为 0，所以 flex 元素不会超过它们 flex-basis 的尺寸。flex-shrink 的值为 1, 所以可以缩小 flex 元素来防止它们溢出。flex-basis 的值为 auto. Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。</p><p><code>flex: auto</code> 等同于 flex: 1 1 auto；和上面的 flex:initial 基本相同，但是这种情况下，flex 元素在需要的时候<strong>既可以拉伸也可以收缩</strong>。</p><p><code>flex: none</code> 可以把 flex 元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。元素既不能拉伸或者收缩，但是元素会按具有 flex-basis: auto 属性的 flexbox 进行布局。</p><p>经常看到的 flex: 1 或者 flex: 2 等等。它相当于flex: 1 1 0 或者 flex: 2 1 0。元素可以在 flex-basis 为 0 的基础上伸缩。</p><h2 id="order" tabindex="-1">order <a class="header-anchor" href="#order" aria-label="Permalink to &quot;order&quot;">​</a></h2><p>定义项目的排列顺序。数值越小，排列越靠前，默认为0，可为负数；</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221208122054233.png" alt="image-20221208122054233"></p><h2 id="align-self" tabindex="-1">align-self <a class="header-anchor" href="#align-self" aria-label="Permalink to &quot;align-self&quot;">​</a></h2><p>允许单个项目与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><p>除auto外，其余与align-items类似。在上述<strong>容器中的align-items</strong>有提到此属性。</p><p><img src="https://cdn.jsdelivr.net/gh/hr1201/img@main/imgs/image-20221208122504955.png" alt="image-20221208122504955"></p><hr>',112),o=[i];function n(s,d,p,g,h,c){return r(),t("div",null,o)}const m=e(a,[["render",n]]);export{x as __pageData,m as default};
